// Copyright 2024 Dimitrios Papakonstantinou. All rights reserved.
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.

use std::fmt::Display;

use crate::lexer::TokenType;

#[derive(Eq, PartialEq, Debug, Clone)]
pub enum Item {
    Program,
    FunctionDefinition,
    Function(String),
    Statement,
    Expression,
    Constant(isize),
}

#[derive(Debug, Clone)]
pub struct ParseNode {
    children: Vec<Option<ParseNode>>,
    entry: Item,
}

impl ParseNode {
    pub fn new() -> Self {
        Self {
            children: Vec::new(),
            entry: Item::Function("program".to_string()),
        }
    }
}

// Parse the token vector and creates the AST
pub struct Parser<'p> {
    tokens: &'p mut Vec<TokenType>, // Tokens generated by lexer
    current: usize,                 // Current index in Token Vector
    nodes: ParseNode,
}

impl<'p> Parser<'p> {
    // Initialise Parser struct
    pub fn new(tokens: &'p mut Vec<TokenType>) -> Self {
        Self {
            tokens,
            current: 0,
            nodes: ParseNode::new(),
        }
    }

    fn parse_statement(&mut self) -> ParseNode {
        self.expect(TokenType::ReturnKeyword);
        let return_val = self.parse_exp(); //TODO
        self.expect(TokenType::Semicolon);

        return return_val;
    }

    fn parse_exp(&mut self) -> ParseNode {
        let token = match self.tokens.get(self.current) {
            Some(item) => item,
            None => panic!("Error retrieving value at index {}", self.current),
        };

        let item = match token {
            TokenType::Constant(c) => Item::Constant(*c),
            _ => todo!(),
        };

        ParseNode {
            entry: item,
            children: vec![None, None],
        }
    }

    // Check if the current token is corrent with the languages grammer
    fn expect(&mut self, expected: TokenType) -> () {
        //TODO consider using pop instead of get
        let actual = self.tokens.get(self.current).unwrap_or_else(|| {
            panic!("Failed to retrieve Token");
        });

        if *actual != expected {
            panic!(
                "Syntax error. Expected Token: {}. Actual Token: {}",
                expected, *actual
            );
        } else {
            self.tokens.remove(self.current);
        }
    }
}

impl<'p> Display for Parser<'p> {
    //TODO
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.nodes.children.iter().for_each(|child| {
            match child {
                Some(item) => write!(f, "{}", item.entry).expect("Couldn't print child"),
                None => write!(f, "").expect("Couldn't print empty child"),
            };
        });
        Ok(())
    }
}

impl<'p> Display for Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Program => write!(f, "Program"),
            Self::FunctionDefinition => write!(f, "FunctionDefinition"),
            Self::Function(name) => write!(f, "Function {}", name),
            Self::Statement => write!(f, "Statement"),
            Self::Expression => write!(f, "Expression"),
            Self::Constant(con) => write!(f, "Constant {}", con),
        }
    }
}
